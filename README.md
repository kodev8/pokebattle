# Kalev Keil - EPITA International BSc Design Patterns

----------
##  🎮 PokeBattle Project Overview
----------

For this project, I decided to replicate Pokemon from the GameBoy era such as Pokemon Leaf Green and Fire Red. 

The game starts with a quick intro by Professor Oak. Once the intro is completed, the user can pick a number of Pokemon from the majority of the 1281 Pokemon available on the PokeApi. After selecting the Pokemon, the user can explore the hometown level. Here, there are some challengers to battle, as well as some items to pick up to help with the journey. The current items obtained are held in the trainer’s bag. If the user loses a battle, the game is over and the user can quit the game or restart by choosing new Pokemon. If all challengers have been defeated, the user is notified by Professor Oak that they have won the game and can restart, continue exploring, or end the game.
If needed, there is a controls menu for each stage of the game.

Here is the project structure:


    🗃️ pokebattle.zip
    ├─ 🎮pokebattle.py
    ├─ 🧰requirements.txt
    ├─ 📃READ_ME.md ( + pdf)
    ├─ 📂assets ...
    ├─ 🛠️config
    │  ├─ ⚙️config.py
    │  ├─ 🌐fetcher.py
    │  └─ 🖇️gamestate.py
    ├─ 🕹️gameplay
    │  ├─ ⚔️battle.py
    │  ├─ 📷camera.py
    │  ├─ 👀dataobservers.py
    │  ├─ 🏞️environments.py
    │  ├─ ✅event_handlers.py
    │  ├─ 💥hit_detection.py
    │  ├─ 🪜levels.py
    │  ├─ 🎮play_level.py
    │  ├─ 🎭render_level.py
    │  ├─ ⌛timers.py
    ├─ 👷🏽‍♂️gui_builders
    │  ├─ 🖼️gui.py
    │  └─ 🚲pickup.py
    └─ 👾sprites
       ├─ 😈challenger.py
       ├─ 🐣pokemon.py
       ├─ 🧓🏽professor_oak.py
       ├─ 📎sprites.py
       ├─ 📑spritesheet.py
       └─ 🏃🏽trainer.py

©generated by Project Tree Generator


## 🧰 **Requirements**
----------

Dependencies:

- pygame
- pytmx
- asyncio
- aiohttp
- Tiled

**pygame and pytmx**
pygame module was used to the extent of rendering sprites, detecting some collisions, playing sounds, and grouping sprites together.
pytmx was used to load maps created in **Tiled**.

asyncio and aiohttp were used to make asynchronous requests to the pokeapi to ensure that the main game loop was not interrupted when awaiting a response from the api.
 
You can install all the requirements by running the following command from the project folder:


    pip install -r requirements.txt
## 🟢 Quick Start
----------

 **After installing** [**requirements**](https://www.dropbox.com/scl/fi/jeyr78bk1ahmah58gqyxw/Kalev-Keil-EPITA-International-BSc-Design-Patterns.paper?dl=0&rlkey=mqu0heacg308ymflha0ow6sjw#:uid=163039933560630887676146&h2=%F0%9F%A7%B0-Requirements)
From the main project directory run:

     python pokebattle.py

The game will open in a new window and can be played from there.

📖

----------
## ⚛️ Design Patterns
----------

For this project, the SOLID Principles and Design Patterns played a major role in promoting modularity and loose coupling between classes. I tried to focus on dependency injection, dependency inversion, and single responsibility (where applicable) etc. Although some classes may have more than one responsibility, at times it felt more cumbersome to abstract and introduce a new class. However, most classes only have one general responsibility. For these classes I created the necessary interfaces and abstract classes to comply with SOLID principles This way, most classes depend on abstractions rather than Concrete Implementations.
Here the design patterns used to create this project will be discussed:


## Creational Patterns

The **creational patterns** used include:

- Singleton
- Factory
- Builder

**Singleton**
The Singleton Pattern was used to ensure that only one class instance was made and could be referenced globally. For example, gamestate.py contains two singleton classes: the `**GameState**` Class and `**GampPlayer**`. The GameState class is responsible for managing the state/stages of the game and is used throughout many different parts of the code. The state of the game needs to be managed and maintained in a constant manner. Hence I decided to use a singleton. Similar to GamesState, GamePlayer is responsible for rendering and playing the game. there should only be one instance of this class because it maintains what levels have been rendered and should be re-rendered(if needed). Having separate instances may cause concurrency issues with rendering.

The **FetchPokemon** class in fetcher.py is similar to the singleton pattern.  It is used to keep track of the Pokemon fetched from the API by using its own class variables to store the data fetched. However, in future implementations, I imagined that there might be new methods of fetching asynchronously or Fetching locally, for example, using a local database. Hence I did not opt for the singleton as this allows me to be more flexible in choosing the `FetchMethod`.

The `**ProfessorOak**` ****Class is also a singleton. Only one instance of this class is required throughout the game. With this design, ProfessorOak and his current state can be accessed globally and also be used to control certain parts of the game like the event handlers in the **Welcome Level**

**Factory.**
The Factory Method is used to create `**Level**` of the game. Since the state of the game is managed by the singleton **GameState**, this state is then used to create the respective level. Using this factory allowed for easy addition or removal of a stage since it abstracts the creation process of level and also complies with the Single Responsibility and Open/Closed principles. For this factory, I also tried to focus on Dependency Injection which allowed for even greater flexibility and modularity. Each level has a renderer, a player, and an event handler. Each of these has several dependencies which are injected at runtime. For the most part, this decoupled each level from most of its dependencies and made it easier to alter the dependencies without breaking the level code.

    class LevelFactory:
        """ Level Factory - Creates levels based on the given state"""
        @staticmethod
        def create_level(level_type, screen, gamestate=None):
            if 'hometown' in level_type:
                return HometownLevelCreator.create(screen, gamestate)
            elif level_type == 'choose':
                return ChooseLevelCreator.create(screen, gamestate)
            elif level_type == 'welcome':
                return WelcomeLevelCreator.create(screen, gamestate)
            elif level_type == 'battle':
                return BattleLevelCreator.create(screen, gamestate)
            elif level_type == 'loading':
                return LoadingLevelCreator.create(screen, gamestate)
            elif level_type == 'controls':
                return ControlsLevelCreator.create(screen, gamestate)
            else:
                return None
    # sample level where the dependencies are injected rather that created within the level. This inversion of control helps manage complexity and promotes separation of concerns.
    class HometownLevelCreator:
        @staticmethod
        def create(screen, gamestate):
            renderer = HomeTownRenderer(
                camera=ExploreCamera(),
                backdrop_renderer=GameMapTSX,
                backdrop_file=r'assets/hometown/hometown.tmx',
                baselayer=Layer(),
                ysortlayer=YSortLayer(),
                item_creator=ItemDirector(ItemBuilder()))
            return HomeTownLevel(
                screen=screen,
                gamestate=gamestate,
                renderer=renderer,
                player_hit=HitDetection(),
                trainer=LevelStore.trainer_mediator.notify('get'),
                data_observable=LevelStore.explore_observable
            )

**Builder**
The builder pattern is used in this project in the gui_builders folder. It is used to create `**GUIElements**` and `**Buttons**`. This pattern was implemented for its benefit of creating highly customizable and complex GUI elements while abstracting the creation of the elements from their future implementation in their respective **level_player**. The majority of the UI elements are built with the builder pattern.
This is also used to set up `**PickUpItems**`. These items are the which can be collected by the Trainer. Using this pattern can allow for many different items to be created in future implementations.


## Structural Patterns

The **structural patterns** used include:

- Bridge
- Decorator
- Facade
- Flyweight

**Bridge**
The `**FetchPokemon**` ****class uses the Bridge pattern by abstracting the fetch method (`**fetch**`) from its implementation (`**async_method**` and `**local_method**`). This abstraction allows the `**FetchPokemon**` class to switch between different fetch methods without affecting the overall class structure promoting loose coupling between these classes. The choice of fetch method is determined by the `**designate_fetch_method**` method.

**Decorator**
A simple implementation of the decorator was used in environments.py. Here, two classes: `**DecoratorPositiveFilter**` and `**DecoratorNegativeFilter**`, are used to filter the sprites within a layer by a given type of class (provided as an argument). These were used to extend the functionality of the `**get_sprites**` method defined without changing the initial implementation of get sprites. This again allowed these classes to maintain compliance with the SOLID principles

**Facade**
The Facade Pattern was used throughout this game. This is made possible thanks to both principles of Dependency Inversion and Dependency Injection.
Dependency inversion allowed most classes to be coupled with interfaces rather than concrete classes as mentioned before. For example, `**FetchPokemon**` implements the `**fetch()**` ``method which then calls the `**fetch()**` method of another `**FetchMehthod**` class. The `**FecthAsync**` class is quite complicated but since this is abstracted from the fetcher, the fetcher now has a simplified interface to fetch data using the more complex `**FetchMethod**` class.

Also in the main game loop, using the `**GamePlay.play_level()**` is a simplified interface to the respective level’s `**play_level()**` method which is a lot more complex.


**Flyweight**
The flyweight factory was used to create the environment tiles in environments.py (**FlyweightTileFactory**). Since many tile images are reused, especially in the base layer of the map (non-collideable layer), I decided to use the Flyweight pattern. After doing some research and testing, I found that the images can be hashed and this was used to keep reference to the images. Hence, a tile’s image is its intrinsic state since this can be shared by many tiles. On the other hand, one tile’s position is the extrinsic state as this property varies significantly from one tile to the next.


## Behavioral Patterns

The **behavioral patterns** used include:

- Chain of responsibility
- Iterator
- Mediator
- Observer
- State

**Chain of Responsibility**
This pattern was used in the `**EventHandler**` for each level. This provided an efficient and centralized but modular way to access event handlers. Each keyboard or mouse event is passed down the series of event handlers until the respective handler for that level is found.  If no handler is found or the event is not included in the allowed events (checked by conditionals), the event is ignored. This may add performance overhead since the event handlers are always listening for events and must be set up and stored in memory even when they are not being used.

**Iterator**
A simple implementation of the iterator pattern was put in place to iterate over the `**Lineup**` of Pokemon of the Trainer/Challenger (the aggregate). These iterators at the current time are simply the same as lists but in future implementations, I plan to have a more complex setup for iterating over the Lineups. For example, iterating while checking/altering the state of the Pokemon to perform different actions. For now, they are used to iterate normally through the list and have accessor methods to get the current Pokemon in the Lineup. Fainted Pokemon are removed from the Lineups and the battle only continues when both the challenger and trainer Lineups contain Pokemon.

**Mediator**
There are two main mediators that allow classes to communicate with each other:

1. The `**TrainerMediator**`: This mediator provides several notification methods that accept certain messages and allow setting or getting attributes of the **Trainer**. This class is also responsible for maintaining the current instance of the Trainer class and ensures that only one class is created at a time.  New trainer instances are required to restart the game, but during the game, any class that needs need to communicate with the trainer must do so through the mediator to ensure that the correct instance is referenced. This decouples the trainer from any other class that needs to communicate with it.
2. The `**BattleMediator**`: This mediator allows the trainer‘s lineup to communicate effectively with any of the challengers’ lineups without each of them knowing much about the other. The mediator requires two Lineups and performs the necessary operations to accommodate a battle between the two Lineups. This promotes loose coupling between the two lineups.

**Observer**
*The observer pattern implemented is a mix of the mediator and observer pattern. Normally, the observable  (subject) updates its observers about its own state in a one-to-many relationship. However, I decided to create a structure to allow for many-to-many relationships. These are `**DataObservables**` in dataobservables.py. They use the typical setup of the observer pattern with attach, detach and notify observers. In addition, they also have set, unset and reset methods which update the data in the observable. Once the data has been updated, the observable notifies all of its observers, even the one who triggered the update. All the observers are then updated. This maintains concurrency of the data between the data observable and all of its observers. 

**State**
The state pattern is used in the `**Trainer**` and `**Professor Oak**` classes to animate these sprites based on their current states. The Trainer and Professor Oak classes are the contexts and their relevant concrete states are defined in their respective files. Each of them is defined with an initial state rather than being injected. The trainer has 3 states which define its movement i.e. walking, running, and biking. Professor Oak has several states which define his speeches and images and are used to determine what his next state should be. The `**OakBye**`, `**OakWin**`, and `**OakLose**` also allow for changing the game’s state when necessary. The implementation allows to easily create new states and most times, each state is not tightly coupled with another state but always references the context.


## ❌ Issues Faced
----------


- Choosing Design Patterns -  Having the liberty of selecting any design pattern was a bit difficult to determine which patterns should be used 
- Detecting collisions - This is still not perfect because of the various shapes and sizes of tiles.
- Handling turns during a battle - Using the mediator helped rectify issues with handling turns between the trainer and challenger. I attempted to use the observer pattern and state patterns but it added complexity and was harder to follow for me. Pokemon states and batter states can be implemented using state pattern, but since these are normally booleans or counters, I preferred to keep the simpler implementation of using dictionaries to maintain their states
- Since this is a smaller project, I understand that some abstractions and better patterns should be made for future implementations.
- Bugs: 
    - Some objects that the trainer should collide with do not work and the trainer can ‘phase’ through them. A higher framerate sometimes fixes this but it is still buggy sometimes
    - Performing too many asynchronous fetches can cause the game to crash. Since the requests to the API are queued, a backlog of requests can cause the game to freeze first and then maybe crash
    - Sometimes, initializing pygame’s mixer does not work and may cause the game to crash. For now, it is in a try and except block to handle this error. If this error is encountered, try plugging in a pair of headphones and then unplugging them
    - Pygame png warning: libpng warning: iCCP: known incorrect sRGB profile in pygame occurs when using pngs instead of jpgs 


## 📝 Project References
----------
- Pygame introduction: https://www.youtube.com/watch?v=AY9MnQ4x3zk
- Help with collisions:  https://www.youtube.com/watch?v=YWN8GcmJ-jA&t=3062s&pp=ygUGcHlnYW1l
- Design Pattern Info: https://refactoring.guru/
- Design Pattern Playlist: https://www.youtube.com/watch?v=_BpmfnqjgzQ&t=9s
- Tips on Dependency Injection, Inversion, and Decoupling: https://www.youtube.com/watch?v=2ejbLVkCndI&t=1s, https://www.youtube.com/watch?v=eiDyK_ofPPM, 
- async python HTTP requests: https://www.twilio.com/blog/asynchronous-http-requests-in-python-with-aiohttp

